from pydantic import BaseModel
import json
import jinja2
import asyncio
import os
from maketools.services.code_executor import CodeExecutorService

CODE_EXECUTION_TEMPLATE = jinja2.Template("""
import json
import sys
from agents.function_schema import function_schema
from pydantic import BaseModel
from typing import Callable, TypeVar, Type, Any, get_type_hints
from functools import wraps
import inspect

T = TypeVar('T', bound=BaseModel)

def convert_to_model(data: Any, model_type: Type[BaseModel]) -> BaseModel:
    '''Helper function to convert data to a Pydantic model.'''
    if isinstance(data, model_type):
        return data
    if isinstance(data, dict):
        # If the data is a nested dict with a key matching the model name (case-insensitive)
        model_name = model_type.__name__.lower()
        for key, value in data.items():
            if key.lower() == model_name and isinstance(value, dict):
                return model_type(**value)
        # If no matching key found, try to use the dict directly
        return model_type(**data)
    return data

def pydantic_auto_convert(func: Callable) -> Callable:
    '''
    Decorator that automatically converts dictionary inputs to Pydantic models based on type hints.
    Expects a single dictionary argument containing all parameters.
    '''
    @wraps(func)
    def wrapper(data: dict, **kwargs):
        sig = inspect.signature(func)
        type_hints = get_type_hints(func)
        new_kwargs = {}
        
        # Process each parameter
        for param_name, param in sig.parameters.items():
            param_type = type_hints.get(param_name)
            
            if param_type and issubclass(param_type, BaseModel):
                # Handle Pydantic model parameters
                new_kwargs[param_name] = convert_to_model(data, param_type)
            elif param_name in data:
                # Handle regular parameters
                new_kwargs[param_name] = data[param_name]
            elif param.default is not inspect.Parameter.empty:
                # Use default value if available
                new_kwargs[param_name] = param.default
            else:
                # Required parameter not found
                raise ValueError(f"Missing required argument: {param_name}")
        
        return func(**new_kwargs)
    return wrapper

                                                                              

{{code}}
result = pydantic_auto_convert(run)(json.loads(sys.argv[1]))

# Wrap the result in a pydantic model to be able to serialize it to json
from typing import Any
class Wrapper(BaseModel):
    wrapped: Any
print('<$output>', json.dumps(Wrapper(wrapped=result).model_dump()['wrapped']), '</$output>')                                
""")

async def run_code(function_code: str, inputs: dict, json_schema: dict, current_dir: str=None) -> dict:
    """
    Run a function and return the result
    Args:
        function_code: The code of the function to run
        json_schema: The json schema of the function
        inputs: The inputs to the function
    Returns:
        result: The result of the function
    """
    rendered_code = CODE_EXECUTION_TEMPLATE.render(code=function_code)
    output = await CodeExecutorService.execute_code([rendered_code, json.dumps(inputs)], start_token="<$output>", end_token="</$output>", current_dir=current_dir)
    return output


if __name__ == "__main__":
    FUNCTION_PATH = 'test_new_function/function_pydantic.py'
    json_schema_path = os.path.join(os.path.dirname(FUNCTION_PATH), f'{FUNCTION_PATH.rsplit('/', maxsplit=1)[-1].split(".")[0]}.json')
    with open(FUNCTION_PATH, 'r', encoding='utf-8') as f:
        function_code = f.read()
    with open(json_schema_path, 'r', encoding='utf-8') as f:
        json_schema = json.load(f)

    # For the example, normally it will be generated by the AI
    inputs = {"point": {"long": 1, "lat": 2}, "options": {"unit": "km"}}
    code_result = asyncio.run(run_code(function_code, inputs, json_schema, current_dir=os.path.dirname(FUNCTION_PATH)))
    print(code_result)




"""
In backend side : when code generated :
- We evaluate the code with get_type_hints to get the type hints of the function
- We create an openapi schema from the type hints (using pydantic-openapi-helper)
"""