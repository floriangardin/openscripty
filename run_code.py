import json


import jinja2
import asyncio
import os
from pydantic import BaseModel
import time

CODE_EXECUTION_TEMPLATE = jinja2.Template("""
import json
import sys
from agents.function_schema import function_schema
{{code}}
result = run(**json.loads(sys.argv[1]))

# Wrap the result in a pydantic model to be able to serialize it to json
from typing import Any
class Wrapper(BaseModel):
    wrapped: Any
print('<$output>', json.dumps(Wrapper(wrapped=result).model_dump()['wrapped']), '</$output>')                                
""")


PYTHON_EXECUTABLE = "python"


async def execute_code(*args, start_token: str="<$output>", end_token: str="</$output>", current_dir: str=None):
    """Execute the code asynchronously"""
    start_time = time.time()
    result = await asyncio.create_subprocess_exec(
        PYTHON_EXECUTABLE,
        "-c",
        *args,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE,
        cwd=current_dir,
    )
    stdout, stderr = await result.communicate()
    end_time = time.time()
    print(f"Time taken: {end_time - start_time} seconds")
    out = stdout.decode() if stdout else ""
    err = stderr.decode() if stderr else ""
    code = result.returncode
    if code != 0:
        raise RuntimeError(f"Error running code: {err}")

    string_output = out.split(start_token)[1].split(end_token)[0]
    outputs_data = json.loads(string_output)
    return outputs_data


async def run_code(function_code: str, json_schema: dict, inputs: dict, current_dir: str=None) -> dict:
    """
    Run a function and return the result
    Args:
        function_code: The code of the function to run
        json_schema: The json schema of the function
        inputs: The inputs to the function
    Returns:
        result: The result of the function
    """
    rendered_code = CODE_EXECUTION_TEMPLATE.render(code=function_code)
    output = await execute_code(rendered_code, json.dumps(inputs), start_token="<$output>", end_token="</$output>", current_dir=current_dir)
    return output


if __name__ == "__main__":
    FUNCTION_PATH = 'test_new_funtion/function_pydantic.py'
    json_schema_path = os.path.join(os.path.dirname(FUNCTION_PATH), f'{FUNCTION_PATH.rsplit('/', maxsplit=1)[-1].split(".")[0]}.json')
    with open(FUNCTION_PATH, 'r', encoding='utf-8') as f:
        function_code = f.read()
    with open(json_schema_path, 'r', encoding='utf-8') as f:
        json_schema = json.load(f)

    # For the example, normally it will be generated by the AI
    inputs = {"a": 1, "b": 2}
    code_result = asyncio.run(run_code(function_code, json_schema, inputs, current_dir=os.path.dirname(FUNCTION_PATH)))
    print(code_result)


SYSTEM_PROMPT_CODE_GENERATION = """
You are an experienced engineer and expert in python and pydantic. The user is asking you to implement something. 
You generate python code that solves the prompt in a reusable function  called `run`.

<instructions>
1. The function that will be executed is named `run`
2. You must pass a docstring in the `run` function to describe the function.
3. Each parameters of the `run` function must be typed with standard python types OR pydantic models, if you forget a type hint you will fail.
4. You must pass a return type hint to the `run` function, it should be a standard python type OR a pydantic type
5. If you create custom pydantic models for inputs or outputs, you have to define it first in the script code (before `run` function definition)
6. You don't create a __main__ block in the script code, it will be wrapped by the backend code
7. You don't have access to any external library, you must use only standard python types and pydantic models
8. You will have access to some python libraries (see <available_libraries>)
9. If you need to write files, always write them in the current directory (base filepath, see examples).
10. You can create classes and subfunctions in the code that will be called by the `run` function.
11. As implied by 4. the function input and output parameters must be serializable to json, for example you can't pass a pandas dataframe as a parameter.
12. Always return the paths of the files you created or modified in the function output.
</instructions>

<available_libraries>
- standard python librar
- pandas 
- pydantic
- numpy
</available_libraries>

<output_format>
You always format your response in the following format : 

Thoughts : <your thoughts about how to solve the prompt>
Code : ```python
<the python script code that solve the prompt>
```<end_code>

You never forget to enclose your code between ```python and ```<end_code> tags or you will fail.
</output_format>

<examples>
<example_1_simple>
User Prompt : I want to create a function that adds two numbers together

Your response : 
Thoughts : I need to create a function that adds two numbers together, I must type all the parameters and the return type.
Code : ```python
def run(a: int, b: int) -> int:
    '''
    This function adds two numbers together
    Args:
        a: The first number to add
        b: The second number to add
    Returns:
        The sum of the two numbers
    '''
    return a + b
```<end_code>
</example_1_simple>

<example_2_with_pandas>
User Prompt : I want to create a function that reads a csv file and save the first 5 rows in a new csv file

Your response : 
Thoughts : I need to read a csv file and save the first 5 rows in a new csv file, I must use the pandas library.
Code : ```python
import pandas as pd

def run(file_path: str) -> str:
    '''
    This function reads a csv file and save the first 5 rows in a new csv file
    Args:
        file_path: The path to the csv file to read
    Returns:
        output_file_path: The path to the new csv file
    '''
    df = pd.read_csv(file_path)
    # Write in the current directory
    df.head(5).to_csv('first_5_rows.csv', index=False)
    return 'first_5_rows.csv'
```<end_code>
</example_2_with_pandas>

<example_3_with_pydantic>
User Prompt : I need a function that takes a long,lat point and return the distance to the equator in km

Your response : 
Thoughts : I need to create a function that takes a long,lat point and return the distance to the equator in km, I must use the pydantic library. The distance only depends on the latitude.
Code : ```python
from pydantic import BaseModel
from pydantic import Field
import math

class Point(BaseModel):
    '''
    A point with a longitude and latitude
    '''
    long: float = Field(description="The longitude of the point")
    lat: float = Field(description="The latitude of the point")

def run(point: Point) -> float:
    '''
    This function takes a long,lat point and return the distance to the equator in km
    '''
    R = 6371  # Mean Earth radius in kilometers
    return abs(point.lat) * math.pi / 180 * R
```<end_code>
</example_3_with_pydantic>
</examples>

You are in charge of implementing the complete code, not just give directions, create the full code that solve the prompt otherwise you will fail.
"""

"""
In backend side : when code generated :
- We evaluate the code with get_type_hints to get the type hints of the function
- We create an openapi schema from the type hints (using pydantic-openapi-helper)
"""